<!DOCTYPE html>
<html lang="en">
	<head>
		<title>GLSL Sandbox</title>
		<meta charset="utf-8">
		<style>

			body {

				background-color: #000000;
				margin: 0px;
				overflow: hidden;

			}

			#code {

				position: absolute;

				padding: 12px;

				border: none;
				border-radius: 5px;

				color: #ffffff;
				background-color: transparent;
				font-family: Monospace;
				font-size: 14px;
				font-weight: bold;
				text-shadow: rgba( 0, 0, 0, 1 ) 0px 1px 2px;

				white-space: pre;

			}

			#code:hover {

				background-color:rgba(0,0,0,.5);

			}

			#tools {

				position: absolute;
				top: 25px;
				left: 25px;

			}

			button {

				padding: 8px 12px 8px 12px;

				border: none;
				border-radius: 5px;
				margin-right: 5px;

				color: #ffffff;
				background-color: #000000;
				opacity: 0.5;

				font-family: Monospace;
				font-size: 12px;
				font-weight: bold;

				cursor: pointer;

			}

			button:hover {

				opacity: 1;

			}

			textarea:focus {

				outline: 0; /* this removes browser-side outline */

			}

		</style>
	</head>
	<body>

		<script src="js/lzma.js"></script>

		<script>

			var compressor = new LZMA( "js/lzma_worker.js" );

			if ( !window.requestAnimationFrame ) {

				window.requestAnimationFrame = ( function() {

					return window.webkitRequestAnimationFrame ||
					window.mozRequestAnimationFrame ||
					window.oRequestAnimationFrame ||
					window.msRequestAnimationFrame ||
					function ( callback, element ) {

						window.setTimeout( callback, 1000 / 60 );

					};

				} )();

			}

			// Greetings to Iq/RGBA! ;)

			var code, canvas, gl, buffer, currentProgram, compileButton,
			vertex_position, parameters = { start_time: Date.now(), time: 0, screenWidth: 0, screenHeight: 0 };

			init();
			animate();

			function init() {

				var effect = document.createElement( 'div' );
				document.body.appendChild( effect );

				canvas = document.createElement( 'canvas' );
				effect.appendChild( canvas );

				//

				code = document.createElement( 'textarea' );
				code.id = 'code';
				code.style.visibility = 'visible';

				code.addEventListener( 'keydown', function ( event ) {

					if ( event.keyCode == 9 ) {

						// Fake TAB

						event.preventDefault();

						var start = code.selectionStart;
						var end = code.selectionEnd;

						code.value = code.value.substring( 0, start ) + '\t' + code.value.substring( end, code.value.length );

						code.selectionStart = code.selectionEnd = start + 1;
						code.focus();

					}

				}, false );

				code.addEventListener( 'keyup', function ( event ) {

					if ( event.keyCode == 37 ) return;
					if ( event.keyCode == 38 ) return;
					if ( event.keyCode == 39 ) return;
					if ( event.keyCode == 40 ) return;

					compile();

				}, false );

				document.body.appendChild( code );

				if ( window.location.hash ) {

					var hash = window.location.hash.substr( 1 );
					var version = hash.substr( 0, 2 );

					if ( version == 'A/' ) {

						// LZMA

						readURL( hash.substr( 2 ) );

					} else {

						// Basic format

						code.value = decodeURIComponent( hash );

					}

				} else {

					readURL( '5d00000100720200000000000000119a48c65ab5aec1f910f780dfdfe473e599a211a90304ab6a650a0bdc710e60d9ef6827f7e37c460aba047c4de9e20bce74f0e6773fe3b4b7d379f6f885aacf346330fef1ffee566139968f57db637a7fabad10c58d9ee59035429f68fd37377ae69569d2c30059acf29a58281c4208405f4e5bc30a50a7c8e7027cfa1ecffac22c377e315721df5df09d053c0ad83443808080b48ad5436340a8c09dfb1728fae483ebf19ff6659d982ab333081cac1172e50f2387c182cfa580d8d4c9750425895835f943e9c0c4071d2ecd0e61e6e65e9b573771dca05873425aad4ad69ea079b9b8481dc3862d5ea10e087f563db734e3298b538a774aac2a000f3595fab1943fc328169b6eff7ce9fa00' );

				}

				//

				var tools = document.createElement( 'div' );
				tools.id = 'tools';
				document.body.appendChild( tools );

				var button = document.createElement( 'button' );
				button.textContent = 'hide code';
				button.addEventListener( 'click', function ( event ) {

					if ( code.style.visibility === 'visible' ) {

						button.textContent = 'show code';
						code.style.visibility = 'hidden';
						compileButton.style.visibility = 'hidden';

					} else {

						button.textContent = 'hide code';
						code.style.visibility = 'visible';
						compileButton.style.visibility = 'visible';

					}

				}, false );
				tools.appendChild( button );


				compileButton = document.createElement( 'button' );
				compileButton.textContent = 'compile';
				compileButton.addEventListener( 'click', function ( event ) {

					compile();

				}, false );
				tools.appendChild( compileButton );

				// Initialise WebGL

				try {

					gl = canvas.getContext( 'experimental-webgl' );

				} catch( error ) { }

				if ( !gl ) {

					alert("WebGL not supported");
					throw "cannot create webgl context";

				}

				// Create Vertex buffer (2 triangles)

				buffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );

				if ( code.value ) compile();

				onWindowResize();
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function compile() {

				var program = gl.createProgram();
				var fragment = document.getElementById( 'code' ).value;

				var vs = createShader( 'attribute vec3 position; void main() { gl_Position = vec4( position, 1.0 ); }', gl.VERTEX_SHADER );
				var fs = createShader( fragment, gl.FRAGMENT_SHADER );

				if ( vs == null || fs == null ) return null;

				gl.attachShader( program, vs );
				gl.attachShader( program, fs );

				gl.deleteShader( vs );
				gl.deleteShader( fs );

				gl.linkProgram( program );

				if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

					console.error( 'VALIDATE_STATUS: ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'ERROR: ' + gl.getError() );
					compileButton.style.color = '#ff0000';
					compileButton.textContent = 'compiled with errors';

					return;

				}

				if ( currentProgram ) {

					gl.deleteProgram( currentProgram );

					setURL( fragment );

				}

				currentProgram = program;

				compileButton.style.color = '#00ff00';
				compileButton.textContent = 'compiled succesfully';

			}

			var dummyFunction = function() {};

			function setURL( shaderString ) {

				compressor.compress( shaderString, 1, function( bytes ) {

					var hex = convertBytesToHex( bytes );
					window.location.replace( '#A/' + hex );

				},
				dummyFunction );

			}

			function readURL( hash ) {

				var bytes = convertHexToBytes( hash );

				compressor.decompress( bytes, function( text ) {

					code.value = text;

					compile();

				},
				dummyFunction );

			}

			function convertHexToBytes( text ) {

				var tmpHex, array = [];

				for ( var i = 0; i < text.length; i += 2 ) {

					tmpHex = text.substring( i, i + 2 );
					array.push( parseInt( tmpHex, 16 ) );

				}

				return array;

			}

			function convertBytesToHex( byteArray ) {

				var tmpHex, hex = "";

				for ( var i = 0, il = byteArray.length; i < il; i ++ ) {

					if ( byteArray[ i ] < 0 ) {

						byteArray[ i ] = byteArray[ i ] + 256;

					}

					tmpHex = byteArray[ i ].toString( 16 );

					// add leading zero

					if ( tmpHex.length == 1 ) tmpHex = "0" + tmpHex;

					hex += tmpHex;

				}

				return hex;

			}

			//

			function createShader( src, type ) {

				var shader = gl.createShader( type );

				gl.shaderSource( shader, src );
				gl.compileShader( shader );

				compileButton.title = '';

				if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

					var error = gl.getShaderInfoLog( shader );

					compileButton.title = error;
					console.error( error );

					compileButton.style.color = '#ff0000';
					compileButton.textContent = 'compiled with errors';

					return null;

				}

				return shader;

			}

			//

			function onWindowResize( event ) {

				code.style.top = '75px';
				code.style.left = '25px';
				code.style.width = ( window.innerWidth - 75 ) + 'px';
				code.style.height = ( window.innerHeight - 125 ) + 'px';

				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;

				parameters.screenWidth = canvas.width;
				parameters.screenHeight = canvas.height;

				gl.viewport( 0, 0, canvas.width, canvas.height );

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				if ( !currentProgram ) return;

				parameters.time = Date.now() - parameters.start_time;

				gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

				// Load program into GPU

				gl.useProgram( currentProgram );

				// Set values to program variables

				gl.uniform1f( gl.getUniformLocation( currentProgram, 'time' ), parameters.time / 1000 );
				gl.uniform2f( gl.getUniformLocation( currentProgram, 'resolution' ), parameters.screenWidth, parameters.screenHeight );

				// Render geometry

				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );
				gl.enableVertexAttribArray( vertex_position );
				gl.drawArrays( gl.TRIANGLES, 0, 6 );
				gl.disableVertexAttribArray( vertex_position );

			}

		</script>

	</body>
</html>
